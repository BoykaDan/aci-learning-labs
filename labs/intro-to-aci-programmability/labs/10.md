## Lab - Toolkit Python Library
The first task will have you configure a Tenant with a VRF and a Bridge Domain using the ACIToolkit library. The Bridge Domain will be associated with the VRF and have 1 subnet that is advertised to routers external to the ACI fabric. The end of the task guides you through confirming and committing the configuration. There is a brief explanation before each step and the actual code you should type is provided in the code blocks.

##### Open a Python terminal
```
$ python
>>>
```

##### Import Libraries
The credentials file is imported for APIC login, and acitoolkit for configuration.
```python
>>> from credentials import *
>>> from acitoolkit.acitoolkit import *
>>> 
```

##### Create a Session with the APIC
The `Session class` and `login function` are used to establish a connection with the APIC. You should see a "200" indicating you succussfully logged into the APIC. URL, LOGIN, and PASSWORD come from importing credentials.
```python
>>> sess = Session(URL, LOGIN, PASSWORD)
>>> sess.login()
<Response [200]>
>>> 
```

##### Create a Tenant with a VRF
A Tenant is a top level object, so whether creating a new Tenant or modifying an existing Tenant's children, this should be the first object defined. A new Tenant is created by passing the Tenant's name (string format) into the `Tenant class`.

When creating a new Tenant, it should also be tied to a VRF. A VRF is created and associated to a Tenant by passing the VRF's name (string format) and tenant object into the `Context class`.
```python
>>> tenant = Tenant("Cisco_Comics")
>>> vrf = Context("Network_Universe", tenant)
>>> 
```

##### Create a Bridge Domain associated with the Tenant and VRF
The next thing you will want to configure for the new Tenant is a Bridge Domain. A Bridge Domain is also a child of the Tenant object, and has a relationship with 1 VRF, 1 or more Subnets, and 1 or more EPGs. A Bridge Domain is created and associated to a Tenant by passing the Bridge Domain's name (string format) and tenant object into the `BridgeDomain class`

The Bridge Domain is assigned to a VRF by calling the `add_context function` on the Bridge Domain object and having the VRF object as the argument.
```python
>>> bd = BridgeDomain("ACI_Way", tenant)
>>> bd.add_context(vrf)
>>> 
```

##### Add a Public Subnet to the Bridge Domain
Now that you have a Bridge Domain created, you will want to assign a Subnet to the Bridge Domain. A Subnet is created and associated to a Bridge Domain by passing the Subnet's name (string format) and Bridge Domain object into the `Subnet class`.

The Subnet is set to be advertised to networks beyond the ACI fabric by calling the `set_scope function` on the Subnet object and passing the string "public" as the argument.

You can assign a subnet and gateway IP by calling the `set_addr function` on the Subnet object and passing in the gateway and subnet mask (string format).
```python
>>> subnet = Subnet("App_Deployer", bd)
>>> subnet.set_scope("public")
>>> subnet.set_addr("10.1.1.1/24")
>>> 
```

##### Confirm Configuration and commit to the APIC
An objects URL and JSON configuration can be retrieved using the `get_url` and `get_json functions` respctively. These functions can be used to print your proposed configuration changes and also to submit the configuration changes. It is always a good idea to check the configuration being submitted before actually commiting it. 

If you would like to have a more readable format, then using the `json` module allows us to manipulate how the python interpreter writes back to the terminal. Another option would be to copy the data to a text editor that can display the JSON to a more readable format.

If the configuration is correct, then you can call the `push_to_apic function` on the Session object. Since the Tenant object is the top level object for all of the configurations, you can pass the `get_url and get_json functions` on the Tenant object as URL and Data arguments. If all of the configuration changes are valid, then the change will be commited to the APIC.
```python
>>> print("\n{}\n\n{}".format(tenant.get_url(), tenant.get_json()))

/api/mo/uni.json

{'fvTenant': {'attributes': {'name': 'Cisco_Comics'}, 'children': [{'fvCtx': {'attributes': {'name': 'Network_Universe', 'pcEnfPref': 'enforced'}, 'children': []}}, {'fvBD': {'attributes': {'name': 'ACI_Way', 'unkMacUcastAct': 'proxy', 'arpFlood': 'no', 'multiDstPktAct': 'bd-flood', 'unicastRoute': 'yes', 'unkMcastAct': 'flood'}, 'children': [{'fvRsCtx': {'attributes': {'tnFvCtxName': 'Network_Universe'}}}, {'fvSubnet': {'attributes': {'ip': '10.1.1.1/24', 'name': 'App_Deployer', 'scope': 'public'}, 'children': []}}]}}]}}

>>> import json
>>> print(json.dumps(tenant.get_json(), sort_keys=True, indent=2, separators=(',',':')))
{
  "fvTenant":{
    "attributes":{
      "name":"Cisco_Comics"
    },
    "children":[
      {
        "fvCtx":{
          "attributes":{
            "name":"Network_Universe",
            "pcEnfPref":"enforced"
          },
          "children":[]
        }
      },
      {
        "fvBD":{
          "attributes":{
            "arpFlood":"no",
            "multiDstPktAct":"bd-flood",
            "name":"ACI_Way",
            "unicastRoute":"yes",
            "unkMacUcastAct":"proxy",
            "unkMcastAct":"flood"
          },
          "children":[
            {
              "fvRsCtx":{
                "attributes":{
                  "tnFvCtxName":"Network_Universe"
                }
              }
            },
            {
              "fvSubnet":{
                "attributes":{
                  "ip":"10.1.1.1/24",
                  "name":"App_Deployer",
                  "scope":"public"
                },
                "children":[]
              }
            }
          ]
        }
      }
    ]
  }
}

>>> resp = sess.push_to_apic(tenant.get_url(), data=tenant.get_json())
>>> 
```

##### Print Back the Results
Since acitoolkit is using the popular `requests` module, there are several options to print back the results of the configuration push. Below is an example that tests for truthiness and either prints a successful message, or an error message.
```python
>>> if resp.ok:
>>>      print("{}: {}\n\n{} is ready for action".format(resp.status_code, resp.reason, subnet.name))
>>> else:
>>>      print("{}: {}\n\n{} has been thwarted\n\n Error: {}".format(resp.status_code, resp.reason, subnet.name, resp.content))
...      
200: OK

App_Deployer is ready for action
>>> exit()
$ 
```
